use std::collections::{BinaryHeap, HashMap, HashSet};
use std::cmp::Ordering;
use std::sync::Arc;

use crate::grafo_metro::{GrafoMetro, IdEstacao, CorLinha, TEMPO_BALDEACAO_MINUTOS};

#[derive(Debug, Clone)]
pub struct EstadoNoFronteira {
    pub id_estacao: IdEstacao,
    pub linha_chegada: Option<CorLinha>,
    pub custo_f: f32,
    pub custo_g_viagem: f32, 
    pub caminho: Vec<IdEstacao>, // Adicionando o caminho percorrido at√© este n√≥
}

impl EstadoNoFronteira {
    pub fn debug_print(&self) -> String {
        format!("E{} (f={:.1}, g={:.1}, h={:.1})", 
                self.id_estacao + 1, 
                self.custo_f, 
                self.custo_g_viagem, 
                self.custo_f - self.custo_g_viagem)
    }

    pub fn debug_full(&self) -> String {
        let caminho_str = self.caminho.iter()
            .map(|&id| format!("E{}", id+1))
            .collect::<Vec<_>>()
            .join(" -> ");
        
        format!("Estado: {}, Caminho: {}", self.debug_print(), caminho_str)
    }
}

// Implementa√ß√µes de PartialEq, Eq, Ord, PartialOrd para EstadoNoFronteira
impl PartialEq for EstadoNoFronteira {
    fn eq(&self, other: &Self) -> bool {
        self.id_estacao == other.id_estacao &&
        self.linha_chegada == other.linha_chegada &&
        (self.custo_f - other.custo_f).abs() < f32::EPSILON &&
        (self.custo_g_viagem - other.custo_g_viagem).abs() < f32::EPSILON
    }
}
impl Eq for EstadoNoFronteira {}
impl Ord for EstadoNoFronteira {
    fn cmp(&self, other: &Self) -> Ordering {
        // Implementa√ß√£o min-heap direta, como no exemplo - menor custo_f tem maior prioridade
        match other.custo_f.partial_cmp(&self.custo_f) {
            Some(order) => order,
            None => Ordering::Equal
        }
    }
}
impl PartialOrd for EstadoNoFronteira {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

#[derive(Debug, Clone)]
pub struct InfoCaminho {
    pub estacoes_do_caminho: Vec<(IdEstacao, Option<CorLinha>)>, 
    pub tempo_total_minutos: f32,
    pub baldeacoes: u32,
}

#[derive(Debug)]
pub enum ResultadoPassoAEstrela {
    EmProgresso,
    CaminhoEncontrado(InfoCaminho),
    NenhumCaminhoPossivel,
    Erro(String),
}

// Novo struct para detalhes da an√°lise
#[derive(Debug, Clone)]
pub struct DetalhesAnalise {
    pub estacao_expandida: IdEstacao,
    pub vizinhos_analisados: Vec<String>,
    pub fronteira_atual: Vec<String>,
}

// Sistema de estados detalhados para visualiza√ß√£o did√°tica
#[derive(Debug, Clone, PartialEq)]
pub enum StatusEstacao {
    Disponivel,
    SelecionadaParaExpansao,    // Tirada da fronteira, vai ser expandida
    ExpandindoVizinhos,         // Analisando seus vizinhos
    AnalisandoBrickWall,        // Verificando se √© brick wall
    BrickWall,                  // Confirmado como brick wall
    VoltandoParaAnterior,       // Processo de voltar para esta√ß√£o anterior
    Explorada,                  // Completamente processada
}

#[derive(Debug, Clone)]
pub struct AnimacaoBrickWall {
    pub id_estacao: IdEstacao,
    pub tempo_inicio: f32,
    pub duracao: f32,
    pub ativa: bool,
}

#[derive(Debug)]
pub struct SolucionadorAEstrela {
    grafo: Arc<GrafoMetro>,
    id_inicio: IdEstacao,
    linha_de_partida_busca: Option<CorLinha>,
    id_objetivo: IdEstacao,
    pub fronteira: BinaryHeap<EstadoNoFronteira>,
    pub explorados: HashSet<IdEstacao>, 
    custos_g_viagem_mapa: HashMap<IdEstacao, f32>, 
    predecessores_info: HashMap<IdEstacao, (IdEstacao, Option<CorLinha>, CorLinha)>,
    pub ultima_analise: Option<DetalhesAnalise>, // Novo campo para armazenar detalhes da √∫ltima an√°lise
    pub estacoes_brick_wall: HashSet<IdEstacao>, // Esta√ß√µes identificadas como becos sem sa√≠da
    pub status_estacoes: HashMap<IdEstacao, StatusEstacao>, // Status de cada esta√ß√£o
    pub animacoes_brick_wall: Vec<AnimacaoBrickWall>, // Anima√ß√µes ativas
    pub estacoes_para_verificar_brick_wall: HashSet<IdEstacao>, // Esta√ß√µes que devem ser verificadas no pr√≥ximo passo
    pub estacao_sendo_explorada_no_momento: Option<IdEstacao>, // Esta√ß√£o que est√° sendo explorada neste momento
    pub estacao_anterior_brick_wall: Option<IdEstacao>, // Esta√ß√£o de onde voltamos ap√≥s encontrar brick wall
    pub passo_atual: usize, // Contador de passos para controle did√°tico
    pub vizinhos_sendo_analisados: HashSet<IdEstacao>, // Vizinhos sendo analisados no passo atual
}

impl SolucionadorAEstrela {
    // PARTE 1: CONFIGURA√á√ÉO DA VIAGEM - Inicializa o algoritmo A*
    // Esta fun√ß√£o √© como abrir um app de mapas e definir origem/destino
    // Define origem, destino e prepara estruturas para busca sistem√°tica
    pub fn novo(
        grafo_compartilhado: Arc<GrafoMetro>,
        id_inicio_param: IdEstacao,
        linha_inicial_opcional: Option<CorLinha>,
        id_objetivo_param: IdEstacao,
    ) -> Self {
        // Cria fronteira: lista ordenada de rotas parciais a serem analisadas
        // A fronteira sempre mant√©m as rotas mais promissoras no topo
        let mut fronteira_heap = BinaryHeap::new();
        let mut custos_g_map = HashMap::new();

        // Calcula estimativa inicial (heur√≠stica h): tempo estimado at√© destino
        // √â como calcular "dist√¢ncia em linha reta" convertida para tempo
        let custo_h_inicial = grafo_compartilhado
            .obter_tempo_heuristico_minutos(id_inicio_param, id_objetivo_param)
            .unwrap_or(0.0);

        // Custo real de viagem (g): zero no ponto de partida
        let custo_g_viagem_inicial = 0.0;
        // Custo total estimado (f): soma do real + estimativa (f = g + h)
        let custo_f_inicial = custo_g_viagem_inicial + custo_h_inicial;

        // Inicializa o caminho percorrido com apenas a esta√ß√£o de partida
        let mut caminho_inicial = Vec::new();
        caminho_inicial.push(id_inicio_param);

        // Adiciona ponto de partida na fronteira como primeira rota a ser analisada
        // Esta √© a √∫nica op√ß√£o inicial para come√ßar a busca
        fronteira_heap.push(EstadoNoFronteira {
            id_estacao: id_inicio_param,
            linha_chegada: linha_inicial_opcional,
            custo_f: custo_f_inicial,
            custo_g_viagem: custo_g_viagem_inicial,
            caminho: caminho_inicial, // Caminho inicial cont√©m s√≥ a origem
        });
        
        custos_g_map.insert(id_inicio_param, custo_g_viagem_inicial);

        Self {
            grafo: grafo_compartilhado,
            id_inicio: id_inicio_param,
            linha_de_partida_busca: linha_inicial_opcional,
            id_objetivo: id_objetivo_param,
            fronteira: fronteira_heap,
            explorados: HashSet::new(),
            custos_g_viagem_mapa: custos_g_map,
            predecessores_info: HashMap::new(),
            ultima_analise: None, // Inicializar como None
            estacoes_brick_wall: HashSet::new(), // Inicializar vazio
            status_estacoes: HashMap::new(), // Inicializar vazio
            animacoes_brick_wall: Vec::new(), // Inicializar vazio
            estacoes_para_verificar_brick_wall: HashSet::new(), // Inicializar vazio
            estacao_sendo_explorada_no_momento: None, // Inicializar como None
            estacao_anterior_brick_wall: None, // Inicializar como None
            passo_atual: 0, // Inicializar contador de passos
            vizinhos_sendo_analisados: HashSet::new(), // Inicializar vazio
        }
    }

    // PARTE 2: BUSCA INTELIGENTE - N√∫cleo do algoritmo A*
    // Esta fun√ß√£o explora sistematicamente as possibilidades para encontrar a rota mais eficiente
    // Executa um passo de an√°lise de cada vez, priorizando rotas mais promissoras
    pub fn proximo_passo(&mut self) -> ResultadoPassoAEstrela {
        self.passo_atual += 1;
        println!("\nüîÑ === PASSO {} ===", self.passo_atual);
        
        // ETAPA 1: Verificar se h√° esta√ß√µes pendentes para verifica√ß√£o de brick wall
        if !self.estacoes_para_verificar_brick_wall.is_empty() {
            let estacao_para_verificar = *self.estacoes_para_verificar_brick_wall.iter().next().unwrap();
            self.estacoes_para_verificar_brick_wall.remove(&estacao_para_verificar);
            
            println!("üîç VERIFICANDO BRICK WALL: Analisando se E{} √© um beco sem sa√≠da", estacao_para_verificar + 1);
            
            // Atualizar status para "analisando brick wall"
            self.status_estacoes.insert(estacao_para_verificar, StatusEstacao::AnalisandoBrickWall);
            
            return ResultadoPassoAEstrela::EmProgresso;
        }
        
        // ETAPA 2: Finalizar verifica√ß√£o de brick wall se estivermos nesse estado
        for (id_estacao, status) in self.status_estacoes.iter() {
            if *status == StatusEstacao::AnalisandoBrickWall {
                let estacao_para_verificar = *id_estacao;
                
                // Verificar se realmente √© brick wall
                if let Some(conexoes) = self.grafo.lista_adjacencia.get(estacao_para_verificar) {
                    let vizinhos_validos: Vec<_> = conexoes.iter()
                        .filter(|c| !self.explorados.contains(&c.para_estacao) && 
                                   !self.estacoes_brick_wall.contains(&c.para_estacao))
                        .collect();
                    
                    if vizinhos_validos.is_empty() {
                        println!("üß± CONFIRMADO BRICK WALL: E{} n√£o tem vizinhos v√°lidos", estacao_para_verificar + 1);
                        
                        // Marcar como brick wall
                        self.estacoes_brick_wall.insert(estacao_para_verificar);
                        self.status_estacoes.insert(estacao_para_verificar, StatusEstacao::BrickWall);
                        self.estacao_anterior_brick_wall = self.estacao_sendo_explorada_no_momento;
                        
                        // Criar anima√ß√£o brick wall
                        self.animacoes_brick_wall.push(AnimacaoBrickWall {
                            id_estacao: estacao_para_verificar,
                            tempo_inicio: 0.0,
                            duracao: 2.0,
                            ativa: true,
                        });
                        
                        // Remover da fronteira se existir
                        self.fronteira.retain(|node| node.id_estacao != estacao_para_verificar);
                        
                        // Criar an√°lise especial para brick wall
                        self.ultima_analise = Some(DetalhesAnalise {
                            estacao_expandida: estacao_para_verificar,
                            vizinhos_analisados: vec!["BRICK WALL: Nenhum vizinho v√°lido".to_string()],
                            fronteira_atual: vec![],
                        });
                        
                        println!("  üîÑ Preparando para voltar e analisar outras op√ß√µes...");
                        return ResultadoPassoAEstrela::EmProgresso;
                    } else {
                        println!("  ‚úÖ E{} ainda tem vizinhos v√°lidos, n√£o √© brick wall", estacao_para_verificar + 1);
                        self.status_estacoes.insert(estacao_para_verificar, StatusEstacao::Explorada);
                    }
                }
                break;
            }
        }
        
        // ETAPA 3: Verificar se estamos voltando de um brick wall
        if let Some(estacao_anterior) = self.estacao_anterior_brick_wall {
            println!("üîô VOLTANDO: Retornando para E{} ap√≥s detectar brick wall", estacao_anterior + 1);
            self.status_estacoes.insert(estacao_anterior, StatusEstacao::VoltandoParaAnterior);
            self.estacao_anterior_brick_wall = None;
            return ResultadoPassoAEstrela::EmProgresso;
        }
        
        // ETAPA 4: Continuar com o algoritmo normal - selecionar pr√≥xima esta√ß√£o
        if let Some(no_da_fronteira_atual) = self.fronteira.pop() {
            println!("üìç SELECIONANDO: Esta√ß√£o E{} (f={:.1}, g={:.1}, h={:.1})", 
                     no_da_fronteira_atual.id_estacao + 1,
                     no_da_fronteira_atual.custo_f,
                     no_da_fronteira_atual.custo_g_viagem,
                     no_da_fronteira_atual.custo_f - no_da_fronteira_atual.custo_g_viagem);
            
            // Atualizar status para "selecionada para expans√£o"
            self.status_estacoes.insert(no_da_fronteira_atual.id_estacao, StatusEstacao::SelecionadaParaExpansao);
            self.estacao_sendo_explorada_no_momento = Some(no_da_fronteira_atual.id_estacao);
            
            // CONDI√á√ÉO DE PARADA: Verificar se chegamos ao objetivo
            if no_da_fronteira_atual.id_estacao == self.id_objetivo {
                let info_caminho = self.criar_info_caminho_do_no(&no_da_fronteira_atual);
                return ResultadoPassoAEstrela::CaminhoEncontrado(info_caminho);
            }
            
            // Ignorar esta√ß√µes j√° exploradas
            if self.explorados.contains(&no_da_fronteira_atual.id_estacao) {
                println!("  ‚è≠Ô∏è Esta√ß√£o E{} j√° explorada, pulando.", no_da_fronteira_atual.id_estacao + 1);
                return ResultadoPassoAEstrela::EmProgresso;
            }
            
            // Voltar √† fronteira para pr√≥ximo passo de expans√£o
            self.fronteira.push(no_da_fronteira_atual);
            return ResultadoPassoAEstrela::EmProgresso;
        }
        
        ResultadoPassoAEstrela::NenhumCaminhoPossivel
    }
    
    // M√©todo auxiliar para expandir uma esta√ß√£o (separado para clareza did√°tica)
    pub fn expandir_estacao_atual(&mut self) -> ResultadoPassoAEstrela {
            self.estacoes_para_verificar_brick_wall.remove(&estacao_para_verificar);
            
            println!("üîç VERIFICANDO BRICK WALL: Analisando esta√ß√£o E{}", estacao_para_verificar + 1);
            
            // Limpar estado de "sendo explorada" pois agora vai ser determinado o status final
            if self.estacao_sendo_explorada_no_momento == Some(estacao_para_verificar) {
                self.estacao_sendo_explorada_no_momento = None;
            }
            
            if let Some(conexoes) = self.grafo.lista_adjacencia.get(estacao_para_verificar) {
                // Verifica se todos os vizinhos j√° foram explorados ou s√£o brick walls
                let vizinhos_validos: Vec<_> = conexoes.iter()
                    .filter(|c| !self.explorados.contains(&c.para_estacao) && 
                               !self.estacoes_brick_wall.contains(&c.para_estacao))
                    .collect();
                
                // Se n√£o tem vizinhos v√°lidos para explorar, √© um brick wall
                if vizinhos_validos.is_empty() {
                    println!("  üß± BRICK WALL CONFIRMADO: E{} n√£o tem mais vizinhos v√°lidos!", 
                            estacao_para_verificar + 1);
                    
                    // Marcar como brick wall
                    self.estacoes_brick_wall.insert(estacao_para_verificar);
                    self.status_estacoes.insert(estacao_para_verificar, StatusEstacao::BrickWall);
                    
                    // Criar anima√ß√£o brick wall
                    self.animacoes_brick_wall.push(AnimacaoBrickWall {
                        id_estacao: estacao_para_verificar,
                        tempo_inicio: 0.0, // Ser√° definido pela GUI
                        duracao: 2.0, // 2 segundos de anima√ß√£o
                        ativa: true,
                    });
                    
                    // Remover esta esta√ß√£o da fronteira se existir
                    self.fronteira.retain(|node| node.id_estacao != estacao_para_verificar);
                    
                    // Criar an√°lise especial para brick wall
                    self.ultima_analise = Some(DetalhesAnalise {
                        estacao_expandida: estacao_para_verificar,
                        vizinhos_analisados: vec!["BRICK WALL: Nenhum vizinho v√°lido".to_string()],
                        fronteira_atual: vec![],
                    });
                    
                    println!("  üîÑ Voltando para analisar outras op√ß√µes...");
                    return ResultadoPassoAEstrela::EmProgresso;
                } else {
                    println!("  ‚úÖ E{} ainda tem vizinhos v√°lidos, n√£o √© brick wall", estacao_para_verificar + 1);
                }
            }
        }
        
        // SEGUNDO: Continuar com o algoritmo normal
        // Pega a rota mais promissora da fronteira (menor f-cost = g + h)
        if let Some(no_da_fronteira_atual) = self.fronteira.pop() {
            println!("EXPANDINDO: Esta√ß√£o E{} (f={:.1}, g={:.1}, h={:.1})", 
                     no_da_fronteira_atual.id_estacao + 1,
                     no_da_fronteira_atual.custo_f,
                     no_da_fronteira_atual.custo_g_viagem,
                     no_da_fronteira_atual.custo_f - no_da_fronteira_atual.custo_g_viagem);
            
            // CONDI√á√ÉO DE PARADA: Verificamos se chegamos ao objetivo
            if no_da_fronteira_atual.id_estacao == self.id_objetivo {
                // Caminho encontrado! Chama fun√ß√£o de apresenta√ß√£o do resultado
                let info_caminho = self.criar_info_caminho_do_no(&no_da_fronteira_atual);
                return ResultadoPassoAEstrela::CaminhoEncontrado(info_caminho);
            }
            
            // Ignora esta√ß√µes j√° completamente exploradas (conjunto fechado)
            if self.explorados.contains(&no_da_fronteira_atual.id_estacao) {
                println!("  Esta√ß√£o E{} j√° explorada, pulando.", no_da_fronteira_atual.id_estacao + 1);
                return ResultadoPassoAEstrela::EmProgresso;
            }
            
            // MARCAR COMO SENDO EXPLORADA NO MOMENTO (para visualiza√ß√£o)
            self.estacao_sendo_explorada_no_momento = Some(no_da_fronteira_atual.id_estacao);
            
            // Marca esta esta√ß√£o como explorada (adiciona ao conjunto fechado)
            self.explorados.insert(no_da_fronteira_atual.id_estacao);
            
            println!("  Explorando conex√µes da esta√ß√£o E{}", no_da_fronteira_atual.id_estacao + 1);
            
            // Prepara estruturas para armazenar detalhes da an√°lise
            let mut vizinhos_analisados = Vec::new();
            let mut fronteira_atual = Vec::new();
            
            // EXPANS√ÉO: Analisa todas as esta√ß√µes vizinhas (conex√µes diretas)
            if let Some(conexoes) = self.grafo.lista_adjacencia.get(no_da_fronteira_atual.id_estacao) {
                for conexao in conexoes {
                    let id_vizinho = conexao.para_estacao;
                    
                    // Pula vizinhos j√° completamente explorados ou marcados como brick wall
                    if self.explorados.contains(&id_vizinho) || self.estacoes_brick_wall.contains(&id_vizinho) {
                        if self.explorados.contains(&id_vizinho) {
                            println!("    Ignorando E{}: j√° explorado", id_vizinho + 1);
                            vizinhos_analisados.push(format!("E{}: j√° explorado", id_vizinho + 1));
                        } else {
                            println!("    Ignorando E{}: brick wall", id_vizinho + 1);
                            vizinhos_analisados.push(format!("E{}: brick wall", id_vizinho + 1));
                        }
                        continue;
                    }
                    
                    // Adicionar informa√ß√£o de dire√ß√£o para depura√ß√£o
                    let heuristica_atual = self.grafo.obter_tempo_heuristico_minutos(
                        no_da_fronteira_atual.id_estacao, self.id_objetivo).unwrap_or(0.0);
                    let heuristica_vizinho = self.grafo.obter_tempo_heuristico_minutos(
                        id_vizinho, self.id_objetivo).unwrap_or(0.0);
                    let direcao = if heuristica_vizinho < heuristica_atual {
                        "APROXIMANDO"
                    } else if heuristica_vizinho > heuristica_atual {
                        "AFASTANDO"
                    } else {
                        "LATERAL"
                    };
                    
                    println!("    Analisando E{} via linha {:?} ({} do objetivo)", 
                             id_vizinho + 1, conexao.cor_linha, direcao);
                    
                    // Calcula custos para esta esta√ß√£o vizinha
                    let custo_baldeacao = if let Some(linha_atual) = no_da_fronteira_atual.linha_chegada {
                        if linha_atual != conexao.cor_linha {
                            println!("      Adicionando custo de baldea√ß√£o: +{}min", TEMPO_BALDEACAO_MINUTOS);
                            TEMPO_BALDEACAO_MINUTOS
                        } else {
                            0.0
                        }
                    } else {
                        0.0 // Primeira esta√ß√£o n√£o tem baldea√ß√£o
                    };
                    
                    // Calcula novo custo real acumulado (g) = g_anterior + tempo_conexao + baldeacao
                    let custo_g_novo = no_da_fronteira_atual.custo_g_viagem + conexao.tempo_minutos + custo_baldeacao;
                    // Obt√©m estimativa at√© o destino (h) para este vizinho
                    let custo_h = self.grafo.obter_tempo_heuristico_minutos(id_vizinho, self.id_objetivo)
                        .unwrap_or(0.0);
                    
                    // Calcula custo total estimado (f) = g + h
                    let custo_f = custo_g_novo + custo_h;
                    
                    println!("      Custos: g_acumulado_anterior={:.1} + tempo_conexao={:.1} + baldeacao={:.1} = g_total_acumulado={:.1}, h={:.1}, f={:.1}", 
                             no_da_fronteira_atual.custo_g_viagem, // Valor g acumulado anterior
                             conexao.tempo_minutos,               // Tempo da conex√£o atual
                             custo_baldeacao,                     // Custo de baldea√ß√£o, se houver
                             custo_g_novo,                        // Novo valor g acumulado total
                             custo_h,                             // Heur√≠stica (possivelmente penalizada)
                             custo_f);
                    
                    // Verificar se j√° existe um caminho melhor para evitar rotas redundantes
                    let mut ja_tem_melhor_caminho = false;
                    
                    // Verifica se j√° h√° um caminho registrado com custo menor
                    if let Some(&custo_g_registrado) = self.custos_g_viagem_mapa.get(&id_vizinho) {
                        if custo_g_registrado <= custo_g_novo {
                            ja_tem_melhor_caminho = true;
                            println!("      J√° existe um caminho melhor registrado com g={:.1}", custo_g_registrado);
                        }
                    }
                    
                    // Verifica fronteira apenas se n√£o encontrou caminho melhor registrado
                    if !ja_tem_melhor_caminho {
                        for no_fronteira in self.fronteira.iter() {
                            if no_fronteira.id_estacao == id_vizinho && no_fronteira.custo_g_viagem <= custo_g_novo {
                                ja_tem_melhor_caminho = true;
                                println!("      J√° existe um caminho melhor na fronteira com g={:.1}", no_fronteira.custo_g_viagem);
                                break;
                            }
                        }
                    }
                    
                    if !ja_tem_melhor_caminho {
                        // Registra este novo caminho como melhor op√ß√£o para esta esta√ß√£o
                        self.custos_g_viagem_mapa.insert(id_vizinho, custo_g_novo);
                        
                        // Armazena informa√ß√£o do predecessor para reconstru√ß√£o do caminho
                        self.predecessores_info.insert(
                            id_vizinho, 
                            (no_da_fronteira_atual.id_estacao, no_da_fronteira_atual.linha_chegada, conexao.cor_linha)
                        );
                        
                        // Cria novo caminho estendendo o atual com este vizinho
                        let mut novo_caminho = no_da_fronteira_atual.caminho.clone();
                        novo_caminho.push(id_vizinho);
                        
                        // Mostra o caminho completo at√© agora para depura√ß√£o
                        let caminho_str = novo_caminho.iter()
                            .map(|&id| format!("E{}", id+1))
                            .collect::<Vec<_>>()
                            .join(" -> ");
                            
                        println!("      Novo caminho: {} (custo g={:.1})", caminho_str, custo_g_novo);
                        
                        // Adiciona novo estado na fronteira para an√°lise futura
                        let novo_no = EstadoNoFronteira {
                            id_estacao: id_vizinho,
                            linha_chegada: Some(conexao.cor_linha),
                            custo_f: custo_f,
                            custo_g_viagem: custo_g_novo,
                            caminho: novo_caminho,
                        };
                        
                        println!("      Adicionando √† fronteira: E{} (f={:.1}, g={:.1}, h={:.1})", 
                                id_vizinho + 1, custo_f, custo_g_novo, custo_h);
                        self.fronteira.push(novo_no);
                        
                        // Adicionar √† lista de vizinhos analisados
                        vizinhos_analisados.push(format!("E{}: g={:.1}, h={:.1}, f={:.1} - ADICIONADO", 
                                                         id_vizinho + 1, custo_g_novo, custo_h, custo_f));
                    } else {
                        vizinhos_analisados.push(format!("E{}: j√° tem caminho melhor", id_vizinho + 1));
                    }
                }
            }
            
            // Capturar estado atual da fronteira para exibi√ß√£o
            let mut nodes_fronteira: Vec<_> = self.fronteira.iter().collect();
            nodes_fronteira.sort_by(|a, b| a.custo_f.partial_cmp(&b.custo_f)
                .unwrap_or(std::cmp::Ordering::Equal));
            
            for node in nodes_fronteira.iter().take(5) {  // Mostrar apenas os 5 melhores
                fronteira_atual.push(format!("E{}: f={:.1}", node.id_estacao + 1, node.custo_f));
            }
            
            // MARCAR PARA VERIFICA√á√ÉO DE BRICK WALL NO PR√ìXIMO PASSO
            // (Apenas se n√£o for o objetivo e se todos os vizinhos foram processados)
            if no_da_fronteira_atual.id_estacao != self.id_objetivo {
                if let Some(conexoes) = self.grafo.lista_adjacencia.get(no_da_fronteira_atual.id_estacao) {
                    // Verifica se todos os vizinhos j√° foram explorados ou s√£o brick walls
                    let vizinhos_validos: Vec<_> = conexoes.iter()
                        .filter(|c| !self.explorados.contains(&c.para_estacao) && 
                                   !self.estacoes_brick_wall.contains(&c.para_estacao))
                        .collect();
                    
                    // Se n√£o tem vizinhos v√°lidos, marcar para verifica√ß√£o no pr√≥ximo passo
                    if vizinhos_validos.is_empty() {
                        println!("  üìã MARCANDO E{} para verifica√ß√£o de brick wall no pr√≥ximo passo", 
                                no_da_fronteira_atual.id_estacao + 1);
                        self.estacoes_para_verificar_brick_wall.insert(no_da_fronteira_atual.id_estacao);
                    }
                }
            }
            
            // Armazenar detalhes da an√°lise
            self.ultima_analise = Some(DetalhesAnalise {
                estacao_expandida: no_da_fronteira_atual.id_estacao,
                vizinhos_analisados,
                fronteira_atual,
            });
            
            // Depois de processar, mostramos a fronteira atualizada
            self.debug_print_fronteira();
            
            ResultadoPassoAEstrela::EmProgresso
        } else {
            ResultadoPassoAEstrela::NenhumCaminhoPossivel
        }
    }

    // PARTE 3: APRESENTA√á√ÉO DO RESULTADO - Constr√≥i o itiner√°rio final detalhado
    // Esta fun√ß√£o √© chamada quando o destino √© alcan√ßado
    // Reconstr√≥i o caminho encontrado e calcula tempo total e baldea√ß√µes
    fn criar_info_caminho_do_no(&self, no_final: &EstadoNoFronteira) -> InfoCaminho {
        let mut estacoes_com_linhas = Vec::new();
        let mut tempo_total = 0.0;
        let mut baldeacoes = 0;
        let _linha_atual: Option<CorLinha> = self.linha_de_partida_busca;
        
        println!("\nDETALHES DO CAMINHO ENCONTRADO:");
        let caminho_str = no_final.caminho.iter()
            .map(|&id| format!("E{}", id+1))
            .collect::<Vec<_>>()
            .join(" -> ");
        println!("Caminho: {}", caminho_str);
        
        // Primeira esta√ß√£o n√£o tem linha de chegada
        if !no_final.caminho.is_empty() {
            estacoes_com_linhas.push((no_final.caminho[0], None));
        }
        
        // Processa cada trecho do caminho para calcular tempos e identificar baldea√ß√µes
        for i in 1..no_final.caminho.len() {
            let id_estacao_atual = no_final.caminho[i];
            let id_estacao_anterior = no_final.caminho[i-1];
            
            let mut linha_usada: Option<CorLinha> = None;
            #[allow(unused_assignments)]
            let mut tempo_conexao = 0.0;
            
            println!("  {}: E{} -> E{} verificando conex√£o direta...",
                   i, id_estacao_anterior + 1, id_estacao_atual + 1);
            
            // Busca a conex√£o espec√≠fica entre as duas esta√ß√µes
            if let Some(conexoes) = self.grafo.lista_adjacencia.get(id_estacao_anterior) {
                for conexao in conexoes {
                    if conexao.para_estacao == id_estacao_atual {
                        linha_usada = Some(conexao.cor_linha);
                        tempo_conexao = conexao.tempo_minutos;
                        
                        tempo_total += tempo_conexao;
                        
                        // Verifica se houve mudan√ßa de linha (baldea√ß√£o)
                        if i > 1 {
                            let linha_anterior = estacoes_com_linhas[i-1].1;
                            if linha_anterior != linha_usada {
                                baldeacoes += 1;
                                tempo_total += TEMPO_BALDEACAO_MINUTOS;
                                println!("  Baldea√ß√£o em E{}: {:?} -> {:?} (+{}min)",
                                       id_estacao_anterior + 1, linha_anterior, linha_usada, TEMPO_BALDEACAO_MINUTOS);
                            }
                        }
                        
                        println!("    Encontrada conex√£o direta: via linha {:?}, tempo={:.1}min",
                               linha_usada.unwrap_or(CorLinha::Nenhuma), tempo_conexao);
                        
                        println!("  E{} -> E{} | Linha: {:?} | Tempo: {:.1}min | Total: {:.1}min",
                               id_estacao_anterior + 1, id_estacao_atual + 1, 
                               linha_usada.unwrap_or(CorLinha::Nenhuma), 
                               tempo_conexao, tempo_total);
                        
                        break;
                    }
                }
            } else {
                println!("  ERRO: Nenhuma conex√£o encontrada de E{} para E{}!",
                       id_estacao_anterior + 1, id_estacao_atual + 1);
            }
            
            estacoes_com_linhas.push((id_estacao_atual, linha_usada));
        }
        
        // Formata e exibe o resultado final
        let horas = (tempo_total as i32) / 60;
        let minutos = (tempo_total as i32) % 60;
        println!("N√∫mero de baldea√ß√µes: {}", baldeacoes);
        println!("Tempo total: {} h {} min ({:.1} min)", horas, minutos, tempo_total);
        
        // Retorna estrutura com informa√ß√µes completas do itiner√°rio
        InfoCaminho {
            estacoes_do_caminho: estacoes_com_linhas,
            tempo_total_minutos: tempo_total,
            baldeacoes,
        }
    }

    // Fun√ß√£o auxiliar para depura√ß√£o da fronteira atual
    pub fn debug_print_fronteira(&self) {
        println!("\nFRONTEIRA ATUAL (ordenada por f-cost crescente):");
        
        // Ordena n√≥s por f-cost para entender as decis√µes do algoritmo
        let mut nodes: Vec<_> = self.fronteira.iter().collect();
        nodes.sort_by(|a, b| a.custo_f.partial_cmp(&b.custo_f)
            .unwrap_or(Ordering::Equal));
        
        for (idx, node) in nodes.iter().enumerate().take(10) {  // Mostra apenas os 10 melhores
            let caminho_str = node.caminho.iter()
                .map(|&id| format!("E{}", id+1))
                .collect::<Vec<_>>()
                .join(" -> ");
                
            println!("  {}. f={:.1} g={:.1} h={:.1} | E{} | {}",
                     idx + 1, 
                     node.custo_f,
                     node.custo_g_viagem,
                     node.custo_f - node.custo_g_viagem,
                     node.id_estacao + 1,
                     caminho_str);
        }
        
        if nodes.len() > 10 {
            println!("  ... e mais {} n√≥s", nodes.len() - 10);
        }
        println!();
    }

    // M√©todo especial para verificar o caminho direto
    pub fn check_direct_path(&self) {
        println!("\nVERIFICANDO CAMINHO DIRETO E6 -> E5 -> E4 -> E13:");
        let path = vec![5, 4, 3, 12]; // E6->E5->E4->E13 (√≠ndices base-zero)
        let mut total_time = 0.0;
        let mut transfers = 0;
        let mut last_line: Option<CorLinha> = None;
        
        for i in 0..(path.len()-1) {
            let from = path[i];
            let to = path[i+1];
            let edge = self.grafo.lista_adjacencia[from].iter()
                .find(|c| c.para_estacao == to);
            
            if let Some(conn) = edge {
                total_time += conn.tempo_minutos;
                
                if let Some(prev_line) = last_line {
                    if prev_line != conn.cor_linha {
                        transfers += 1;
                        total_time += TEMPO_BALDEACAO_MINUTOS;
                        println!("  Baldea√ß√£o em E{}: {:?} -> {:?} (+4min)",
                                 from+1, prev_line, conn.cor_linha);
                    }
                }
                
                println!("  E{} -> E{}: Linha {:?}, {:.1}min (total: {:.1}min)",
                         from+1, to+1, conn.cor_linha, conn.tempo_minutos, total_time);
                
                last_line = Some(conn.cor_linha);
            } else {
                println!("  ERRO: Conex√£o n√£o encontrada entre E{} e E{}", from+1, to+1);
            }
        }
        
        println!("Caminho E6 -> E5 -> E4 -> E13:");
        println!("  Tempo total: {:.1}min ({} h {} min)", 
                 total_time, 
                 (total_time as i32) / 60, 
                 (total_time as i32) % 60);
        println!("  Baldea√ß√µes: {}", transfers);
    }

    // Adicionar um m√©todo para validar a rota espec√≠fica
    pub fn validar_rota_especifica(&self) {
        // Testar especificamente a rota E6 -> E5 -> E4 -> E13
        let estacoes = [5, 4, 3, 12]; // √çndices zero-based 
        let mut tempo_total = 0.0;
        let mut baldeacoes = 0;
        let mut linha_anterior: Option<CorLinha> = None;
        
        println!("\n=== VALIDA√á√ÉO DA ROTA E6 -> E5 -> E4 -> E13 ===");
        
        for i in 0..estacoes.len()-1 {
            let id_origem = estacoes[i];
            let id_destino = estacoes[i+1];
            
            // Encontra a conex√£o correta
            let mut conexao_tempo = 0.0;
            let mut cor_linha = CorLinha::Nenhuma;
            let mut encontrou = false;
            
            if let Some(conexoes) = self.grafo.lista_adjacencia.get(id_origem) {
                for conexao in conexoes {
                    if conexao.para_estacao == id_destino {
                        conexao_tempo = conexao.tempo_minutos;
                        cor_linha = conexao.cor_linha;
                        encontrou = true;
                        break;
                    }
                }
            }
            
            if encontrou {
                tempo_total += conexao_tempo;
                
                // Verificar baldea√ß√£o
                if let Some(linha) = linha_anterior {
                    if linha != cor_linha {
                        baldeacoes += 1;
                        tempo_total += TEMPO_BALDEACAO_MINUTOS;
                        println!("  Baldea√ß√£o em E{}: {:?} -> {:?} (+{}min)",
                               id_origem + 1, linha, cor_linha, TEMPO_BALDEACAO_MINUTOS);
                    }
                }
                
                println!("  E{} -> E{}: Linha {:?}, Tempo={:.1}min, Total acumulado={:.1}min",
                       id_origem + 1, id_destino + 1, cor_linha, conexao_tempo, tempo_total);
                
                linha_anterior = Some(cor_linha);
            } else {
                println!("  ERRO: N√£o existe conex√£o direta de E{} para E{}!",
                       id_origem + 1, id_destino + 1);
            }
        }
        
        println!("TEMPO TOTAL: {:.1}min ({} h {} min)", 
               tempo_total, 
               (tempo_total as i32) / 60, 
               (tempo_total as i32) % 60);
        println!("BALDEA√á√ïES: {}", baldeacoes);
        println!("=================================================\n");
    }
    
    // Chamar este m√©todo de valida√ß√£o durante a inicializa√ß√£o
    pub fn verificar_dados(&self) {
        self.validar_rota_especifica();
    }
    
    // M√âTODOS PARA GERENCIAR BRICK WALLS E ANIMA√á√ïES
    
    // Atualiza anima√ß√µes de brick wall
    pub fn atualizar_animacoes(&mut self, tempo_atual: f32) {
        for animacao in &mut self.animacoes_brick_wall {
            if animacao.ativa && animacao.tempo_inicio == 0.0 {
                animacao.tempo_inicio = tempo_atual;
            }
            
            if animacao.ativa && (tempo_atual - animacao.tempo_inicio) > animacao.duracao {
                animacao.ativa = false;
            }
        }
        
        // Remove anima√ß√µes inativas
        self.animacoes_brick_wall.retain(|a| a.ativa);
    }
    
    // Obt√©m anima√ß√µes ativas
    pub fn obter_animacoes_ativas(&self) -> &Vec<AnimacaoBrickWall> {
        &self.animacoes_brick_wall
    }
    
    // Verifica se uma esta√ß√£o √© brick wall
    pub fn e_brick_wall(&self, id_estacao: IdEstacao) -> bool {
        self.estacoes_brick_wall.contains(&id_estacao)
    }
    
    // Obt√©m status de uma esta√ß√£o
    pub fn obter_status_estacao(&self, id_estacao: IdEstacao) -> StatusEstacao {
        self.status_estacoes.get(&id_estacao).cloned().unwrap_or(StatusEstacao::Disponivel)
    }
}